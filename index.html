<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Safari Stay</title>
  <style>
    :root{
      --bg1:#0f5c43;
      --bg2:#063528;
      --panel: rgba(255,255,255,0.10);
      --stroke: rgba(255,255,255,0.14);
      --text:#fff;
      --gap:10px;
      --tileRadius:14px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      font-family: Arial, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(circle at top, var(--bg1), var(--bg2));
      color: var(--text);
      text-align:center;
      padding: 18px 12px 40px;
    }

    h1{
      margin: 8px 0 10px;
      font-size: 40px;
      letter-spacing: 0.5px;
      font-weight: 800;
    }

    .topbar{
      display:flex;
      justify-content:space-between;
      gap:10px;
      max-width: 520px;
      margin: 0 auto 12px;
      padding: 10px 12px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      backdrop-filter: blur(6px);
    }

    .stat{
      font-size: 16px;
      font-weight: 700;
      white-space:nowrap;
    }
    .stat .v{
      font-variant-numeric: tabular-nums;
    }

    .hint{
      max-width: 520px;
      margin: 8px auto 10px;
      opacity: 0.85;
      font-size: 14px;
      line-height: 1.35;
    }

    .boardWrap{
      display:flex;
      justify-content:center;
      margin-top: 8px;
    }
    #board{
      width: min(420px, 94vw);
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      gap: var(--gap);
      padding: 14px;
      border-radius: 18px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      box-shadow: 0 14px 34px rgba(0,0,0,0.25);
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }

    .tile{
      width:100%;
      aspect-ratio: 1 / 1;
      border-radius: var(--tileRadius);
      border: 2px solid rgba(255,255,255,0.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
      transition: transform 120ms ease, outline 120ms ease, opacity 120ms ease;
      cursor:pointer;
    }
    .tile:active{ transform: scale(0.96); }

    .selected{
      outline: 4px solid rgba(255,255,255,0.90);
      outline-offset: 2px;
      transform: scale(1.03);
    }

    .fading{
      opacity: 0.20;
      transform: scale(0.92);
    }

    .panel{
      max-width: 520px;
      margin: 16px auto 0;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 18px;
      padding: 12px 14px;
      text-align:left;
    }

    .panelRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }

    .panel h2{
      margin: 0 0 4px;
      font-size: 18px;
      letter-spacing: 0.2px;
    }

    .small{
      margin: 0;
      opacity: 0.85;
      font-size: 14px;
      line-height:1.3;
    }

    button{
      border:none;
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 800;
      font-size: 16px;
      background: rgba(255,255,255,0.92);
      color: #064;
      cursor:pointer;
      transition: transform 120ms ease, opacity 120ms ease;
    }
    button:active{ transform: scale(0.98); }
    button[disabled]{ opacity:0.45; cursor:not-allowed; }

    .toast{
      margin-top: 10px;
      min-height: 18px;
      font-size: 14px;
      opacity: 0.9;
      text-align:center;
    }

    .controls{
      max-width: 520px;
      margin: 10px auto 0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      padding: 10px 12px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 16px;
    }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      font-weight: 700;
      font-size: 14px;
      opacity: 0.9;
    }

    .miniBtn{
      padding: 10px 12px;
      font-size: 14px;
      border-radius: 12px;
      background: rgba(255,255,255,0.85);
    }

    @media (max-width: 420px){
      h1{ font-size: 36px; }
      :root{ --gap:8px; --tileRadius:12px; }
      #board{ padding: 12px; }
    }
  </style>
</head>
<body>

  <h1>üå¥ Safari Stay</h1>

  <div class="topbar">
    <div class="stat">üí∞ Coins: <span class="v" id="coins">0</span></div>
    <div class="stat">üèÜ Score: <span class="v" id="score">0</span></div>
    <div class="stat">üìç <span class="v" id="location">Maasai Mara</span> (x<span class="v" id="multiplier">1</span>)</div>
  </div>

  <div class="hint">
    Tap one tile, then tap a <b>neighbor</b> to swap. Only swaps that create a match are allowed (Candy-Crush style).
    Clear <b>3+</b> tiles to earn coins & score. Bigger cascades = combo bonus üî•
  </div>

  <div class="boardWrap">
    <div id="board" aria-label="Match 3 board"></div>
  </div>

  <div class="controls">
    <div class="toggle">
      üîä Sound
      <input type="checkbox" id="soundToggle" checked />
    </div>
    <button class="miniBtn" id="resetBtn">Reset Progress</button>
  </div>

  <div class="panel">
    <div class="panelRow">
      <div>
        <h2 id="nextTitle">Next: Mombasa Beach Stay</h2>
        <p class="small">Upgrade cost: <b id="nextCost">150</b> coins ‚Ä¢ New bonus: <b id="nextMult">x2</b></p>
      </div>
      <button id="upgradeBtn">Upgrade Location</button>
    </div>
    <div class="toast" id="toast"></div>
  </div>

<script>
/* =========================
   SAFARI STAY ‚Äî MATCH-3
   (Candy-Crush style + SFX + Save)
   ========================= */

const size = 8;
const boardEl = document.getElementById("board");

const coinsEl = document.getElementById("coins");
const scoreEl = document.getElementById("score");
const locationEl = document.getElementById("location");
const multiplierEl = document.getElementById("multiplier");

const nextTitleEl = document.getElementById("nextTitle");
const nextCostEl = document.getElementById("nextCost");
const nextMultEl = document.getElementById("nextMult");
const upgradeBtn = document.getElementById("upgradeBtn");

const toastEl = document.getElementById("toast");
const soundToggle = document.getElementById("soundToggle");
const resetBtn = document.getElementById("resetBtn");

/* Colors (tiles) */
const palette = [
  { name: "yellow", hex: "#f1c40f" },
  { name: "blue",   hex: "#3498db" },
  { name: "green",  hex: "#2ecc71" },
  { name: "orange", hex: "#e67e22" },
];

/* Kenyan locations (upgrade increases multiplier) */
const locations = [
  { name: "Maasai Mara", cost: 0,   mult: 1,  label: "Maasai Mara Lodge" },
  { name: "Mombasa",     cost: 150, mult: 2,  label: "Mombasa Beach Stay" },
  { name: "Naivasha",    cost: 350, mult: 3,  label: "Naivasha Eco Lodge" },
  { name: "Amboseli",    cost: 700, mult: 5,  label: "Amboseli View Lodge" },
];

let grid = new Array(size * size).fill(null); // stores color hex strings
let tiles = [];                                // DOM nodes
let selectedIndex = null;
let busy = false;

let coins = 0;
let score = 0;
let locationIndex = 0;

/* -------------------------
   SOUND (Web Audio)
   ------------------------- */
let audioCtx = null;

function canSound(){
  return soundToggle.checked;
}

function ensureAudio(){
  if (!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

/** Simple beep */
function beep(freq=440, dur=0.08, type="sine", gain=0.05){
  if (!canSound()) return;
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + dur);
  }catch(e){}
}

function sfxSelect(){ beep(660, 0.05, "triangle", 0.04); }
function sfxSwap(){ beep(520, 0.06, "square", 0.035); }
function sfxNope(){ beep(180, 0.08, "sine", 0.05); }
function sfxClear(){ beep(880, 0.06, "triangle", 0.05); setTimeout(()=>beep(990,0.05,"triangle",0.04), 40); }
function sfxUpgrade(){ beep(740,0.08,"triangle",0.06); setTimeout(()=>beep(880,0.10,"triangle",0.06), 80); }

/* -------------------------
   SAVE / LOAD
   ------------------------- */
const KEY = "safari_stay_v2";

function save(){
  localStorage.setItem(KEY, JSON.stringify({
    coins, score, locationIndex,
    sound: soundToggle.checked
  }));
}

function load(){
  const raw = localStorage.getItem(KEY);
  if (!raw) return;
  try{
    const data = JSON.parse(raw);
    if (typeof data.coins === "number") coins = data.coins;
    if (typeof data.score === "number") score = data.score;
    if (typeof data.locationIndex === "number" && data.locationIndex >= 0 && data.locationIndex < locations.length){
      locationIndex = data.locationIndex;
    }
    if (typeof data.sound === "boolean") soundToggle.checked = data.sound;
  }catch(e){}
}

resetBtn.addEventListener("click", () => {
  localStorage.removeItem(KEY);
  coins = 0; score = 0; locationIndex = 0;
  buildBoard();
  updateUI();
  setToast("Progress reset ‚úÖ");
});

/* -------------------------
   UI
   ------------------------- */
function setToast(msg=""){
  toastEl.textContent = msg;
}

function updateUI(){
  coinsEl.textContent = coins.toLocaleString();
  scoreEl.textContent = score.toLocaleString();
  locationEl.textContent = locations[locationIndex].name;
  multiplierEl.textContent = String(locations[locationIndex].mult);

  // Upgrade info
  if (locationIndex < locations.length - 1){
    const next = locations[locationIndex + 1];
    nextTitleEl.textContent = `Next: ${next.label}`;
    nextCostEl.textContent = next.cost.toLocaleString();
    nextMultEl.textContent = "x" + next.mult;
    upgradeBtn.disabled = coins < next.cost;
  } else {
    nextTitleEl.textContent = "All Locations Unlocked üéâ";
    nextCostEl.textContent = "-";
    nextMultEl.textContent = "-";
    upgradeBtn.disabled = true;
  }
  save();
}

soundToggle.addEventListener("change", save);

upgradeBtn.addEventListener("click", () => {
  if (locationIndex >= locations.length - 1) return;
  const next = locations[locationIndex + 1];
  if (coins < next.cost){
    setToast("Not enough coins yet.");
    sfxNope();
    return;
  }
  coins -= next.cost;
  locationIndex++;
  setToast(`Welcome to ${locations[locationIndex].name}! üåç`);
  sfxUpgrade();
  updateUI();
});

/* -------------------------
   Board helpers
   ------------------------- */
function randColor(){
  return palette[Math.floor(Math.random() * palette.length)].hex;
}
function idxToRC(i){ return { r: Math.floor(i / size), c: i % size }; }
function rcToIdx(r,c){ return r * size + c; }

function areNeighbors(i1,i2){
  const a = idxToRC(i1), b = idxToRC(i2);
  const dr = Math.abs(a.r - b.r);
  const dc = Math.abs(a.c - b.c);
  return (dr + dc) === 1;
}

function renderTile(i){
  tiles[i].style.backgroundColor = grid[i];
}

function renderAll(){
  for (let i=0;i<grid.length;i++) renderTile(i);
}

function clearSelection(){
  if (selectedIndex !== null){
    tiles[selectedIndex].classList.remove("selected");
    selectedIndex = null;
  }
}

function swap(i1,i2){
  const t = grid[i1];
  grid[i1] = grid[i2];
  grid[i2] = t;
}

/* -------------------------
   Match detection (3+)
   Returns Set of indices
   ------------------------- */
function findMatches(){
  const matched = new Set();

  // Rows
  for (let r=0; r<size; r++){
    let runColor = null;
    let runStart = 0;
    let runLen = 0;

    for (let c=0; c<size; c++){
      const i = rcToIdx(r,c);
      const color = grid[i];

      if (color && color === runColor){
        runLen++;
      } else {
        if (runLen >= 3 && runColor){
          for (let k=runStart; k<runStart+runLen; k++){
            matched.add(rcToIdx(r,k));
          }
        }
        runColor = color;
        runStart = c;
        runLen = color ? 1 : 0;
      }
    }
    if (runLen >= 3 && runColor){
      for (let k=runStart; k<runStart+runLen; k++){
        matched.add(rcToIdx(r,k));
      }
    }
  }

  // Columns
  for (let c=0; c<size; c++){
    let runColor = null;
    let runStart = 0;
    let runLen = 0;

    for (let r=0; r<size; r++){
      const i = rcToIdx(r,c);
      const color = grid[i];

      if (color && color === runColor){
        runLen++;
      } else {
        if (runLen >= 3 && runColor){
          for (let k=runStart; k<runStart+runLen; k++){
            matched.add(rcToIdx(k,c));
          }
        }
        runColor = color;
        runStart = r;
        runLen = color ? 1 : 0;
      }
    }
    if (runLen >= 3 && runColor){
      for (let k=runStart; k<runStart+runLen; k++){
        matched.add(rcToIdx(k,c));
      }
    }
  }

  return matched;
}

/* -------------------------
   Gravity: drop tiles down and refill top
   ------------------------- */
function dropAndRefill(){
  for (let c=0; c<size; c++){
    let writeRow = size - 1;

    // Move non-empty down
    for (let r=size-1; r>=0; r--){
      const i = rcToIdx(r,c);
      if (grid[i]){
        const w = rcToIdx(writeRow,c);
        if (w !== i){
          grid[w] = grid[i];
          grid[i] = null;
        }
        writeRow--;
      }
    }

    // Refill remaining at top
    for (let r=writeRow; r>=0; r--){
      grid[rcToIdx(r,c)] = randColor();
    }
  }
}

/* -------------------------
   Resolve matches loop (cascades)
   - clears matches
   - drops + refill
   - repeats until stable
   Adds score/coins with combo bonus
   ------------------------- */
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

async function resolveBoard(){
  let totalCleared = 0;
  let combo = 0;

  while (true){
    const matches = findMatches();
    if (matches.size === 0) break;

    combo++;
    totalCleared += matches.size;

    // little visual fade
    matches.forEach(i => tiles[i].classList.add("fading"));
    sfxClear();
    await sleep(140);

    // clear from grid
    matches.forEach(i => {
      grid[i] = null;
      tiles[i].classList.remove("fading");
    });
    renderAll();
    await sleep(70);

    // gravity + refill
    dropAndRefill();
    renderAll();
    await sleep(90);
  }

  if (totalCleared > 0){
    const mult = locations[locationIndex].mult;

    // scoring model:
    // score: 50 per tile * mult + combo bonus
    // coins: 10 per tile * mult + combo bonus
    const comboBonus = Math.max(0, combo - 1) * 100 * mult;

    const gainedScore = (totalCleared * 50 * mult) + comboBonus;
    const gainedCoins = (totalCleared * 10 * mult) + Math.floor(comboBonus / 10);

    score += gainedScore;
    coins += gainedCoins;

    setToast(`Cleared ${totalCleared} tiles ‚Ä¢ Combo x${combo} üî•  +${gainedCoins} coins  +${gainedScore} score`);
    updateUI();
    return true;
  }

  return false;
}

/* -------------------------
   Tile taps (Candy Crush swap rules)
   ------------------------- */
async function handleTap(i){
  if (busy) return;

  // first tap
  if (selectedIndex === null){
    selectedIndex = i;
    tiles[i].classList.add("selected");
    sfxSelect();
    return;
  }

  // second tap
  if (selectedIndex === i){
    clearSelection();
    return;
  }

  const a = selectedIndex;
  const b = i;

  // must be neighbors
  if (!areNeighbors(a,b)){
    // change selection to the new tile
    tiles[a].classList.remove("selected");
    selectedIndex = b;
    tiles[b].classList.add("selected");
    sfxSelect();
    return;
  }

  // attempt swap
  busy = true;
  tiles[a].classList.remove("selected");
  selectedIndex = null;

  swap(a,b);
  renderTile(a); renderTile(b);
  sfxSwap();

  // check if swap creates any match
  const matchesAfter = findMatches();
  if (matchesAfter.size === 0){
    // swap back
    await sleep(140);
    swap(a,b);
    renderTile(a); renderTile(b);
    setToast("No match ‚Äî swap back.");
    sfxNope();
    busy = false;
    return;
  }

  // resolve cascades
  setToast("");
  await resolveBoard();
  busy = false;
}

/* -------------------------
   Build board
   ------------------------- */
function buildBoard(){
  boardEl.innerHTML = "";
  tiles = [];
  grid = new Array(size * size).fill(null);

  for (let i=0;i<grid.length;i++){
    grid[i] = randColor();
  }

  for (let i=0;i<grid.length;i++){
    const d = document.createElement("div");
    d.className = "tile";
    d.addEventListener("click", () => handleTap(i));
    boardEl.appendChild(d);
    tiles.push(d);
  }

  renderAll();
}

/* Remove starting matches so the first move feels fair */
async function cleanStart(){
  busy = true;
  await resolveBoard();
  busy = false;
}

/* -------------------------
   Start
   ------------------------- */
load();
buildBoard();
updateUI();
cleanStart();
</script>

</body>
</html>
